---
title: "Impulse model"
author: "Michael Smallegan"
date: "10/14/2020"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)
library(tidyverse)
library(DESeq2)
library(broom)
source("../util/_plot_theme.R")
```

Okay, for now, since I haven't actually seen any profiles that look quite like 
the impulse model, I'll just fit the sigmoid model. 

It makes sense to use the rlog counts sense they are normalized and the
dispersion for low counts is taken care of. 

We'll start with generating those counts.

```{r}
genes <- rtracklayer::import(file.path("../util/",
                                       "gencode.vM25.annotation.genes.gtf"))
names(genes) <- genes$gene_id

g2s <- genes %>% as.data.frame() %>%
  dplyr::select(gene_id, gene_name)

salmon_gene_counts <- read.csv(file.path("../../rnaseq/results/salmon/",
                                         "salmon_merged_gene_counts.csv")) %>%
  column_to_rownames("gene_id") %>%
  as.matrix()
mode(salmon_gene_counts) <- "integer"


samples <- read.csv("../../rnaseq/rnaseq_samplesheet.csv") %>%
  filter(cell_type != "pMEF",
         date_sequenced != "2018-09",
         timepoint_minutes < 400,
         timecourse_length == "short") %>%
  mutate(firre_ko = factor(firre_ko, levels = c("WT", "KO")),
         timepoint_minutes = factor(timepoint_minutes, 
                                    levels = c(seq(0,360,30))),
         firre_induced = factor(firre_induced, 
                                levels = c("control", "firre_induced")))
rownames(samples) <- samples$sample_id

# Probably makes sense to do this separately for ESC and NPC
esc_samples <- samples %>% 
  filter(cell_type == "ESC")
# Filter to just the data we're using
esc_counts <- salmon_gene_counts[,esc_samples$sample_id]

genes <- genes[rownames(esc_counts)]
```

```{r}
stopifnot(all(rownames(esc_samples) == colnames(esc_counts)))
stopifnot(all(names(genes) == rownames(esc_counts)))
  
dds <- DESeqDataSetFromMatrix(countData = esc_counts, 
                              colData = esc_samples, 
                              design = ~ firre_induced + firre_ko,
                              rowData = genes)

# Filter low counts
dds <- dds[rowSums(counts(dds)) >= 10,]

esc_rlog_counts <- rlog(dds, blind = FALSE)

esc_rlog_countsl <- assay(esc_rlog_counts) %>%
  as.data.frame() %>%
  rownames_to_column("gene_id") %>%
  pivot_longer(2:ncol(.), names_to = "sample_id", values_to = "rlog_count") 
esc_rlog_countsl <- esc_rlog_countsl %>%
  merge(esc_samples %>% dplyr::select(sample_id, cell_type, firre_ko, 
                                      firre_induced, timepoint_minutes)) %>%
  merge(g2s)
esc_rlog_countsl$timepoint_minutes <- as.numeric(as.character(esc_rlog_countsl$timepoint_minutes))
esc_rlog_countsl <- esc_rlog_countsl %>%
  arrange(gene_id, timepoint_minutes)

write_rds(esc_rlog_countsl, "results/esc_rlog_counts.RDS")
esc_rlog_countsl <- read_rds("results/esc_rlog_counts.RDS")
esc_rlog_countsl$timepoint_minutes <- as.numeric(as.character(esc_rlog_countsl$timepoint_minutes))
```



```{r}
# By subtracting the zero timepoint rlog counts from all other timepoints,
# it's effectively like the log2 fold change from zero, since rlog counts
# are roughly the log2 counts
# From the DEseq2 vignette: "[rlog] computes a variance stabilizing 
# transformation which is roughly similar to putting the data on the 
# log2 scale, while also dealing with the sampling variability of low counts.

# For now, we'll also remove this sample (JR2432)
# which has a lot of outlier genes
# TODO: Figure out what's going on with this sample.
esc_rlog_countsl <- esc_rlog_countsl %>% 
  filter(sample_id != "JR2432")

esc_rlog_counts_zero_centered <- esc_rlog_countsl %>%
  group_by(gene_id, gene_name, firre_ko, firre_induced) %>%
  mutate(rlog_count = rlog_count - mean(rlog_count[timepoint_minutes == 0])) %>%
  ungroup()

# Triage genes that are more or less not changing, so that we
# don't have to compute the curve fitting for so many genes. 

dynamic <- esc_rlog_counts_zero_centered %>%
  group_by(gene_id, gene_name, firre_ko, firre_induced, timepoint_minutes) %>%
  # Take the mean to deal with outliers
  summarize(lfc = mean(rlog_count)) %>%
  group_by(gene_id, gene_name) %>%
  summarize(max_lfc = max(abs(lfc), na.rm = T)) %>%
  # 0.08 is ~50th percentile and is a very small change
  filter(max_lfc > stats::quantile(.$max_lfc, 0.5))


rlog_counts <- esc_rlog_counts_zero_centered %>%
  filter(gene_id %in% dynamic$gene_id)


# If each gene takes 5 seconds to curve fit, let's consider the best way to 
# divide. I estimate a total of about 22 hours, so if we divide into 
# about twenty batches, each should take an hour. That's about
# 800 genes per batch
n_batches <- 20
batches <- rlog_counts %>% 
  dplyr::select(gene_id) %>%
  distinct() %>%
  mutate(batch = sample(1:n_batches, nrow(.), replace=T))

rlog_counts <- rlog_counts %>%
  merge(batches)

rlog_counts %>% 
  nest_by(batch) %>%
  pmap(~write_rds(x = .y, 
                  path = paste0("results/rlog_counts/batch_", .x, ".rds"))) %>%
  invisible()

```

```{r}
batches <- 1:n_batches

create_sbatch_script <- function(batch) {

line <- paste0("#!/bin/bash
#SBATCH -p short
#SBATCH --job-name=fit_timecourse_", batch, "
#SBATCH --mail-type=NONE
#SBATCH --mail-user=michael.smallegan@colorado.edu
#SBATCH --nodes=1
#SBATCH --ntasks=1
#SBATCH --mem=30gb
#SBATCH --time=4:00:00
#SBATCH --output=fit_tc_", batch, ".out
#SBATCH --error=fit_tc_", batch, ".err
date
Rscript fit_timecourse.R ", batch, "
date
")
writeLines(line, 
           con = paste0("bin/fit_tc_", batch, ".sbatch"))
}

lapply(batches, create_sbatch_script) %>% 
  invisible()
# Create submit script
cat(paste0("#!/bin/bash \n",
              paste(paste0("sbatch ", paste0("fit_tc_", batches, ".sbatch")),
              collapse = "\n")),
    file = "bin/submit.sh")
# TODO: this is a really cheap and messy way to do caching
if(!file.exists("results/curve_fits/batch_1.rds")) {
  system("source /etc/profile; cd bin; chmod u+x submit.sh; ./submit.sh")
}
```

```{r}
# Import results.
curve_fits <- tibble(batch = 1:n_batches) %>%
  mutate(curve_fits = map(batch, ~ read_rds(paste0("results/curve_fits/batch_", .x, ".rds")))) %>%
  unnest(curve_fits)

write_rds(curve_fits, "results/curve_fits.rds")
curve_fits <- curve_fits %>%
  
curve_fits$
batch1 <- readRDS("results/curve_fits/batch_1.rds")

batch1 <- batch1 %>%
  mutate(lm_tidy = map(lm_fit, tidy),
         sigmoid_tidy = map(sigmoid_fit, tidy),
         impulse_tidy = map(impulse_fit, tidy),
         lm_bic = map(lm_fit, BIC),
         sigmoid_bic = map(sigmoid_fit, BIC),
         impulse_bic = map(impulse_fit, BIC))

choose_best_model <- function(bic_list) {
  unlist(strsplit(names(bic_list)[which.min(bic_list)], "_"))[[1]]
}
batch1$best_model <- apply(batch1[,c("lm_bic","sigmoid_bic", "impulse_bic")],
                            1, choose_best_model)

batch1_sigmoid <- batch1 %>%
  unnest(sigmoid_tidy)
# batch1 <- batch1 %>%
#   unnest(impulse_tidy)
plot_timecourse_fits("Klf4", batch1)

unique(batch1_sigmoid$term)
good_ones <- batch1_sigmoid %>%
  filter(term == "rate") %>%
  filter(p.value < 0.05)
# Cool gene list
# Slc29a3
# Ahdc1
# Fv1

```


```{r}


goi <- c("Firre", "Sox2", "Gfap", "Adgrg1", "Duox1")
goi <- "Firre"

curve_fits <- rlog_counts  %>%
  filter(gene_name %in% goi) %>%
  dplyr::select(gene_id, gene_name, timepoint_minutes, 
                rlog_count, firre_ko, firre_induced) %>%
  unite(condition, firre_ko, firre_induced) %>%
  # Center zero timepoint at zero
  group_by(gene_id, gene_name, condition) %>%
  ungroup() %>%
  nest(timecourse = c(timepoint_minutes, rlog_count)) %>%
  mutate(lm_fit = map(timecourse, ~ lm(rlog_count ~ 0 + timepoint_minutes, data = .)),
         sigmoid_fit = map(timecourse, ~ cmp_fit_sigmoid_wrapper(.$rlog_count, .$timepoint_minutes)),
         impulse_fit = map(timecourse, ~ cmp_fit_impulse_wrapper(.$rlog_count, .$timepoint_minutes))) 

curve_fits <- curve_fits %>%
  mutate(lm_tidy = map(lm_fit, tidy),
         sigmoid_tidy = map(sigmoid_fit, tidy),
         impulse_tidy = map(impulse_fit, tidy),
         lm_bic = map(lm_fit, BIC),
         sigmoid_bic = map(sigmoid_fit, BIC),
         impulse_bic = map(impulse_fit, BIC))

choose_best_model <- function(bic_list) {
  unlist(strsplit(names(bic_list)[which.min(bic_list)], "_"))[[1]]
}
curve_fits$best_model <- apply(curve_fits[,c("lm_bic","sigmoid_bic", "impulse_bic")],
                            1, choose_best_model)


plot_timecourse_fits <- function(gene, fit_df) {
  


og_augmented <- fit_df %>%
  filter(gene_name == gene) %>%
  mutate(lm_augmented = map(lm_fit, augment),
         sigmoid_augmented = map(sigmoid_fit, augment),
         impulse_augmented = map(impulse_fit, augment))%>%
  unnest(c(lm_augmented, sigmoid_augmented, impulse_augmented), names_sep = "_") %>%
  dplyr::select(gene_id, gene_name, condition, lm_augmented_timepoint_minutes,
                lm_augmented_rlog_count, lm_augmented_.fitted, impulse_augmented_.fitted,
                sigmoid_augmented_.fitted, best_model) %>%
  pivot_longer(cols = c(lm_augmented_.fitted, 
                        sigmoid_augmented_.fitted,
                        impulse_augmented_.fitted),
               names_to = "model", values_to = "fitted_counts") %>%
  mutate(model = sub("\\_.*", "", model),
         is_best = ifelse(model == best_model, "solid", "dashed")) 

g <- ggplot(og_augmented, aes(x = lm_augmented_timepoint_minutes, 
                          y = lm_augmented_rlog_count, 
                          group = model, color = model, linetype = is_best)) + 
  geom_hline(yintercept = 0, color = "#E0E2E1") +
  geom_vline(xintercept = 0, color = "#E0E2E1") +
  geom_line(aes(y = fitted_counts), size = 1.1, alpha = 0.9) + 
  geom_point(color = "#424242") +
  facet_wrap(~condition) +
  scale_linetype_identity() + 
  scale_color_manual(values = c("#5BBA62", "#a8404c", "#024059")) + 
  ggtitle(paste(unique(og_augmented$gene_name), " | ", 
                           unique(og_augmented$gene_id))) + 
  xlab("t") +
  ylab("Abundance")

return(g)
}

plot_timecourse_fits("Firre", curve_fits)
# Lars2 outlier in sample JR2432
# Also RN7sk in sample JR2432
```

```{r}
one_tc <- esc_rlog_countsl %>%
  filter(firre_induced == "firre_induced", 
         firre_ko == "WT",
         gene_name == "Firre") %>%
  arrange(timepoint_minutes)
zero_tp_val <- mean(one_tc[one_tc$timepoint_minutes == 0,"rlog_count"])
x <- as.numeric(as.character(one_tc$timepoint_minutes))
y <- one_tc$rlog_count
y <- y - zero_tp_val
plot(y~x)

sigmoid_fit <- fit_sigmoid_wrapper(y, x)
impulse_fit <- fit_impulse_wrapper(y, x)
lm_fit <- lm(y~0+x)
plot(y~x)
# lines(x, sigmoid_fun(x,v_inter = -0.1, t_rise =180, rate = 0.9))
lines(unique(x), 
      predict(lm_fit, newdata = data.frame(x = unique(x))), col = "red")
lines(unique(x), 
      predict(impulse_fit, newdata = data.frame(x = unique(x))), col = "green")
lines(unique(x), 
      predict(sigmoid_fit, newdata = data.frame(x = unique(x))), col = "blue")

```

